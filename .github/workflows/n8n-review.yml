name: Trigger n8n Webhook with Complete PR Info

on:
  pull_request:
    types: [opened, synchronize, reopened]
    # Only run on internal repositories to prevent external data exposure
    branches: [main, develop]

permissions:
  contents: read  # Reduced from write to read-only
  pull-requests: write

jobs:
  gather-and-send:
    runs-on: ubuntu-latest
    # Only run for trusted users/organizations and limit concurrency
    if: github.event.pull_request.head.repo.full_name == github.repository && github.actor != 'dependabot[bot]'
    concurrency:
      group: n8n-webhook-${{ github.event.pull_request.number }}
      cancel-in-progress: true
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Generate Run UUID
        id: uuid
        run: echo "run_token=$(uuidgen)" >> $GITHUB_OUTPUT

      - name: Fetch PR metadata
        id: pr
        uses: octokit/request-action@v2.x
        with:
          route: GET /repos/${{ github.repository }}/pulls/${{ github.event.pull_request.number }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Fetch limited PR files metadata
        id: files
        uses: octokit/request-action@v2.x
        with:
          route: GET /repos/${{ github.repository }}/pulls/${{ github.event.pull_request.number }}/files
          mediaType: |
            {
              "previews": ["application/vnd.github.v3+json"]
            }
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Combine and send minimal data to n8n webhook
        id: n8n
        env:
          PR_DATA: ${{ steps.pr.outputs.data }}
          FILES_DATA: ${{ steps.files.outputs.data }}
          RUN_TOKEN: ${{ steps.uuid.outputs.run_token }}
          N8N_WEBHOOK_URL: ${{ secrets.N8N_WEBHOOK_URL }}
        run: |
          set -e
          
          # Validate webhook URL is configured
          if [ -z "$N8N_WEBHOOK_URL" ]; then
            echo "Error: N8N_WEBHOOK_URL secret is not configured"
            exit 1
          fi

          # Extract only necessary PR information to limit data exposure
          PR_NUMBER=$(echo "$PR_DATA" | jq -r '.number')
          PR_TITLE=$(echo "$PR_DATA" | jq -r '.title')
          PR_STATE=$(echo "$PR_DATA" | jq -r '.state')
          PR_AUTHOR=$(echo "$PR_DATA" | jq -r '.user.login')
          
          # Validate PR data before processing
          if [ "$PR_NUMBER" = "null" ] || [ -z "$PR_NUMBER" ]; then
            echo "Error: Invalid PR number"
            exit 1
          fi
          
          # Sanitize and limit file information (only collect non-sensitive metadata)
          FILES_COUNT=$(echo "$FILES_DATA" | jq 'length')
          # Only collect filenames, not content or patches
          FILE_NAMES=$(echo "$FILES_DATA" | jq -r '.[].filename' | head -5 | grep -E '\.(md|txt|yml|yaml|json)$' | jq -R -s -c 'split("\n") | map(select(length > 0))')
          
          # Additional privacy check - exclude sensitive file patterns
          SAFE_FILE_NAMES=$(echo "$FILE_NAMES" | jq -r '.[]' | grep -v -E '\.(key|pem|p12|pfx|env|secret)$' | jq -R -s -c 'split("\n") | map(select(length > 0))')
          
          # Create sanitized payload with minimal necessary data
          cat > payload.json <<EOF
          {
            "pr_number": $PR_NUMBER,
            "pr_title": $(echo "$PR_TITLE" | sed 's/[^a-zA-Z0-9 ._-]//g' | jq -R .),
            "pr_state": $(echo "$PR_STATE" | jq -R .),
            "pr_author": $(echo "$PR_AUTHOR" | jq -R .),
            "files_count": $FILES_COUNT,
            "safe_file_names": $SAFE_FILE_NAMES,
            "repository": "${{ github.repository }}",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "token": "$RUN_TOKEN"
          }
          EOF

          # Post to n8n and capture response with timeout and retry
          RESPONSE=$(timeout 30 curl -s -w "\n%{http_code}" -X POST \
            -H "Content-Type: application/json" \
            -H "User-Agent: GitHub-Actions" \
            --max-time 25 \
            --retry 2 \
            --retry-delay 5 \
            --data @payload.json \
            "$N8N_WEBHOOK_URL")

          HTTP_BODY=$(echo "$RESPONSE" | sed '$d')
          HTTP_STATUS=$(echo "$RESPONSE" | tail -n1)

          echo "n8n responded with status: $HTTP_STATUS"
          # Don't log response body as it may contain sensitive data
          echo "n8n response received"

          # Save response body to file for next step
          echo "$HTTP_BODY" > response_body.json

          # Robust jq extraction, stripping stray quotes
          STATUS=$(echo "$HTTP_BODY" | jq -r ".status" | tr -d '"')
          MATCHED=$(echo "$HTTP_BODY" | jq -r ".token" | tr -d '"')

          if [ "$MATCHED" != "$RUN_TOKEN" ] || [ "$STATUS" != "completed" ]; then
            echo "n8n workflow did not complete correctly or token mismatch"
            exit 1
          fi

          # Fail if HTTP status not 2xx
          if [ "$HTTP_STATUS" -lt 200 ] || [ "$HTTP_STATUS" -ge 300 ]; then
            echo "n8n workflow failed or did not complete successfully"
            exit 1
          fi

          # Clean up payload file containing sensitive data
          rm -f payload.json

      - name: Post n8n feedback to PR (if feedback was provided)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          RESPONSE_BODY=$(cat response_body.json)
          COMMENT=$(echo "$RESPONSE_BODY" | jq -r ".comment" | tr -d '"')
          PR_NUMBER=$(echo "$RESPONSE_BODY" | jq -r ".pr_number" | tr -d '"')
          if [ -n "$COMMENT" ] && [ "$COMMENT" != "null" ]; then
            echo "Posting feedback to PR #$PR_NUMBER"
            gh pr comment "$PR_NUMBER" --body "$COMMENT"
          else
            echo "No comment to post."
          fi
          
          # Clean up response file containing potentially sensitive data
          rm -f response_body.json 